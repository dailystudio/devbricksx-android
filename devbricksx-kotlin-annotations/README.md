# Devbricks X Kotlin Annoations
This library provides annotations that simplify your development work with **ViewModel**, **Fragment**, etc.

## Installation
To use annotation and its compiler, add the following dependencies in build.gradle of your application.

#### Jcenter

```groovy
repositories { 
    jcenter()
}
```

#### Dependencies

```groovy
dependencies {
    implementation "com.dailystudio:devbricksx:$devbricksx_version"
    implementation "com.dailystudio:devbricksx-kotlin-annotations:$devbricksx_version"

    kapt "com.dailystudio:devbricksx-kotlin-compiler:$devbricksx_version"

    // (Optional) Annotations and processors to generate low-level facilities, such as Dao, Database, etc. 
    implementation "com.dailystudio:devbricksx-java-annotations:$devbricksx_version"
    kapt "com.dailystudio:devbricksx-java-compiler:$devbricksx_version"
    kapt "androidx.room:room-compiler:2.2.5"
}
```

#### Latest version

```groovy
devbricksx_version = "0.6.8"
```

If you want to auto-generate low-level facilities of an object class, such as **Dao**, **Database**, etc., DO NOT forget to include devbricksx-java-anntations and related compiler. See [devbricksx-java-annotations](../devbricksx-java-annotations/README.md) for more information.

## Quick Sample

Let's base on the **User** class we define in [devbricks-java-annotations](../devbricksx-java-annotations/README.md). Now we want to create an user interface for **User** class. It represents as a list of all the users that are stored in the database:

```kotlin
@RoomCompanion(primaryKeys = ["uid"],
        autoGenerate = true,
        extension = UserDaoExtension::class
)
@ViewModel
@Adapter(viewHolder = UserViewHolder::class)
@ListFragment
data class User(@JvmField val uid: Int,
                @JvmField val firstName: String?,
                @JvmField val lastName: String?)


@DaoExtension(entity = User::class)
interface UserDaoExtension {
    @Query("SELECT * FROM user WHERE uid IN (:userIds)")
    fun loadAllByIds(userIds: IntArray): List<User>

    @Insert
    fun insertAll(vararg users: User)
}

class UserViewHolder(itemView: View): AbsSingleLineViewHolder<User>(itemView) {

    override fun getIcon(item: User): Drawable? {
        return ResourcesCompatUtils.getDrawable(itemView.context,
                R.mipmap.ic_launcher)
    }

    override fun getText(item: User): CharSequence? {
        return buildString {
            append(item.firstName)
            append('.')
            append(item.lastName)
        }
    }

}
```
With a few lines of codes, you get a fragment named **UsersFragment**. You only need to add three annotations @ViewModel, @Adapter, and @ListFragment on **User** class and create a UserViewHolder class to map the data fields into the UI elements. 

With only around 40 lines, you get get an UI like this:

![](../docs/assets/samples.png)

## Annotations

### 1. ViewModel
This annotation helps you generate a ViewModel class of an object class, like **User**. It extends from AndroidViewModel and encapsulates a Repository inside it.

The generated **ViewModel** class includes the following interfaces (use **User** class as an example) :

Interfaces | Descriptions
:--        | :--
allUsers | a LiveData of all the users
allUsersPaged | a LiveData of PagedList of users
insertUser(user) | Insert a user
insertUsers(users) | Insert a list of users
updateUser(user) | Update a object
updateUsers(users) | Update a list of users
insertOrUpdateUser(user) | Insert a user or update if it exists
insertOrUpdateUsers(users) | Insert a list of users or update them if they are alreay existed
deleteUser(user) | Delete a user

The suffix of interfaces' names is different according to the name of the object class. For example, the interface of inserting a **Group** object is **insertGroup()**.

#### Parameters

- **group**
    
   Different object classes can share the same **ViewModel**. The interfaces of classes with the same group name will be generated in one ViewModel class.


- **repository**
    
    By default, all low-level implementations of generated **ViewModel** class are using an auto-generated Repository class by [devbricksx-java-annotations](../devbricksx-java-annotations/README.md). If you want to use your Repository for extension purposes. You can extend from the one which is auto-generated by our library or just write a completely new one. But if you start from scratch, you need to implement all the pre-defined functions which are described above.

### 2. Adapter
It will generate a **RecyclerAdapter** for you which derives from our abstract class **AbsPagedListAdapter**. It helps simplify the work of writing a recycler adapter. 

#### Parameters

- **viewHolder**
    
    Specify a **ViewHolder** class which is used to map the field of data objects into UI elements. If must be extended from our abstract class **AbsViewHolder**. **AbsViewHolder** provides you an interface, named **bind()** for mapping easily. For a simple layout, you can directly use **AbsSingleLineViewHolder** for convenience.

- **viewType**
    
    Indicate the layout of the item in the list. By default, it is **ViewType.SingleLine**, which means to use our pre-defined single-line item layout. If you want to use your layouts, set this parameter to **ViewType.Customized**

- **layout**
    
    If **viewType** is set to **ViewType.Customized**. This field will be used to specify which layout XML should be used to create an item view.


### 3. ListFragment
It helps you to generate a fragment with a list of objects of the target class. 
It retrieves the data through the **ViewModel** which is generated by **@ViewModel** annotation. If you want to retrieve the data in your way, inherit from the generated Fragment and override the function **getLiveData()**.

#### Parameters

- **layout**

    By default, the layout of this fragment is pre-defined in **Devbricks X** library. But you can specify your layout XML file. If you write your customized layout, it should include a **RecyclerView** and its identifier must be **android.R.id.list**.
    
- **gridLayout**    

    By default, we user **LinearLayoutManager** to manage the layout of **RecycelerView**. You can set this parameter to true to use **GridLayoutManager**.

- **columns**    

    Specify the columns which are used for **GridLayoutManager**. By default, it is 2.
